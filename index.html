<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>林業GIS Pro - Field</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons for intuitive UI -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- QRCode.js for generating QR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        /* 現場での意図しないスクロールやズームを防止 */
        body { 
            overscroll-behavior-y: none; 
            user-select: none; 
            -webkit-user-select: none; 
            touch-action: none;
        }
        /* 地図の代わりとなる背景パターン */
        .map-bg {
            background-color: #f8fafc;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        /* 横スクロールバーを隠す */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-slate-900 flex flex-col h-screen overflow-hidden font-sans text-slate-800">

    <!-- Header / Counters -->
    <header class="bg-slate-800 text-white p-3 flex flex-col gap-2 shadow-md z-10">
        <div class="flex justify-between items-center px-1">
            <div class="flex items-center gap-2">
                <i data-lucide="map" class="w-5 h-5 text-emerald-400"></i>
                <h1 class="text-lg font-bold tracking-wider">林業GIS <span class="text-emerald-400">Pro</span></h1>
            </div>
        </div>
        <div class="grid grid-cols-4 gap-2">
            <div class="bg-slate-700 p-1 rounded-lg border-b-4 border-yellow-500 text-center">
                <div class="text-[9px] text-slate-300 font-bold whitespace-nowrap">伐採(本)</div>
                <div class="font-bold text-yellow-400 text-lg" id="ui-count-felling">0</div>
            </div>
            <div class="bg-slate-700 p-1 rounded-lg border-b-4 border-orange-500 text-center">
                <div class="text-[9px] text-slate-300 font-bold whitespace-nowrap">集材(本)</div>
                <div class="font-bold text-orange-400 text-lg" id="ui-count-yarding">0</div>
            </div>
            <div class="bg-slate-700 p-1 rounded-lg border-b-4 border-sky-500 text-center">
                <div class="text-[9px] text-slate-300 font-bold whitespace-nowrap">造材(本)</div>
                <div class="font-bold text-sky-400 text-lg" id="ui-count-bucking">0</div>
            </div>
            <div class="bg-slate-700 p-1 rounded-lg border-b-4 border-green-500 text-center">
                <div class="text-[9px] text-slate-300 font-bold whitespace-nowrap">搬出(台)</div>
                <div class="font-bold text-green-400 text-lg" id="ui-count-forwarding">0</div>
            </div>
        </div>
    </header>

    <!-- Map & Paint Area -->
    <main class="flex-1 relative overflow-hidden flex justify-center items-center p-2 map-bg" id="canvas-container">
        <!-- Canvas for painting -->
        <canvas id="mapCanvas" class="bg-transparent rounded-lg shadow-xl border-2 border-slate-300 touch-none"></canvas>
    </main>

    <!-- Toolbar / Controls -->
    <footer class="bg-slate-100 p-3 flex flex-col gap-3 shadow-[0_-10px_15px_-3px_rgba(0,0,0,0.1)] z-10 rounded-t-3xl">
        <!-- Counters -->
        <div class="grid grid-cols-2 gap-2 px-1">
            <button id="btn-count-felling" class="py-3 bg-slate-800 text-yellow-400 font-bold rounded-xl active:bg-slate-700 text-sm shadow-md transition-transform active:scale-95 flex justify-center items-center gap-1">
                <i data-lucide="plus-circle" class="w-5 h-5"></i> 伐採 +10
            </button>
            <button id="btn-count-yarding" class="py-3 bg-slate-800 text-orange-400 font-bold rounded-xl active:bg-slate-700 text-sm shadow-md transition-transform active:scale-95 flex justify-center items-center gap-1">
                <i data-lucide="plus-circle" class="w-5 h-5"></i> 集材 +10
            </button>
            <button id="btn-count-bucking" class="py-3 bg-slate-800 text-sky-400 font-bold rounded-xl active:bg-slate-700 text-sm shadow-md transition-transform active:scale-95 flex justify-center items-center gap-1">
                <i data-lucide="plus-circle" class="w-5 h-5"></i> 造材 +10
            </button>
            <button id="btn-count-forwarding" class="py-3 bg-slate-800 text-green-400 font-bold rounded-xl active:bg-slate-700 text-sm shadow-md transition-transform active:scale-95 flex justify-center items-center gap-1">
                <i data-lucide="plus-circle" class="w-5 h-5"></i> 搬出 +1
            </button>
        </div>

        <!-- Brushes (Horizontal Scroll) -->
        <div class="flex overflow-x-auto gap-3 px-1 py-1 no-scrollbar snap-x">
            <button id="btn-brush-1" class="brush-btn snap-center shrink-0 w-24 py-3 bg-yellow-400 text-yellow-900 font-bold rounded-2xl border-4 border-transparent focus:outline-none transition-all flex flex-col items-center justify-center gap-1 shadow-md">
                <i data-lucide="axe" class="w-6 h-6"></i>
                <span class="text-xs">伐採済</span>
            </button>
            <button id="btn-brush-2" class="brush-btn snap-center shrink-0 w-24 py-3 bg-orange-400 text-orange-900 font-bold rounded-2xl border-4 border-transparent focus:outline-none transition-all flex flex-col items-center justify-center gap-1 shadow-md">
                <i data-lucide="tractor" class="w-6 h-6"></i>
                <span class="text-xs">集材済</span>
            </button>
            <button id="btn-brush-3" class="brush-btn snap-center shrink-0 w-24 py-3 bg-sky-400 text-sky-900 font-bold rounded-2xl border-4 border-transparent focus:outline-none transition-all flex flex-col items-center justify-center gap-1 shadow-md">
                <i data-lucide="hammer" class="w-6 h-6"></i>
                <span class="text-xs">造材済</span>
            </button>
            <button id="btn-brush-4" class="brush-btn snap-center shrink-0 w-24 py-3 bg-green-400 text-green-900 font-bold rounded-2xl border-4 border-transparent focus:outline-none transition-all flex flex-col items-center justify-center gap-1 shadow-md">
                <i data-lucide="truck" class="w-6 h-6"></i>
                <span class="text-xs">搬出済</span>
            </button>
            <button id="btn-brush-0" class="brush-btn snap-center shrink-0 w-24 py-3 bg-slate-200 text-slate-700 font-bold rounded-2xl border-4 border-transparent focus:outline-none transition-all flex flex-col items-center justify-center gap-1 shadow-md">
                <i data-lucide="eraser" class="w-6 h-6"></i>
                <span class="text-xs">消しゴム</span>
            </button>
        </div>

        <!-- Sync Button -->
        <div class="px-1 pb-1">
            <button id="btn-show-sync" class="w-full py-4 bg-blue-600 text-white font-bold rounded-2xl active:bg-blue-700 text-lg shadow-md transition-transform active:scale-95 flex items-center justify-center gap-2">
                <i data-lucide="qr-code" class="w-6 h-6"></i>
                同期用QRを生成 (Sync Hub)
            </button>
        </div>
    </footer>

    <!-- Sync Modal -->
    <div id="sync-modal" class="hidden fixed inset-0 bg-slate-900/90 z-50 flex flex-col items-center justify-center p-4">
        <div class="bg-white rounded-3xl w-full max-w-md overflow-hidden shadow-2xl flex flex-col max-h-[90vh]">
            <div class="bg-blue-600 p-4 flex justify-between items-center text-white">
                <h2 class="text-xl font-bold flex items-center gap-2"><i data-lucide="refresh-cw"></i> データ同期</h2>
                <button id="btn-close-modal" class="p-2 bg-blue-700 rounded-full active:bg-blue-800"><i data-lucide="x"></i></button>
            </div>
            
            <div class="p-6 overflow-y-auto flex-1 flex flex-col items-center gap-4">
                <p class="text-center font-bold text-slate-600">仲間のスマホでこのQRをスキャン</p>
                
                <!-- QR Code Display -->
                <div id="qrcode-container" class="bg-white p-4 border-4 border-slate-100 rounded-2xl shadow-inner flex justify-center w-full"></div>
                
                <div class="w-full bg-slate-100 p-3 rounded-lg text-xs font-mono text-slate-500 break-all border border-slate-200">
                    <div class="font-bold text-slate-700 mb-1">【圧縮ペイロード (RLE+Base64)】</div>
                    <div id="sync-payload-text"></div>
                </div>

                <hr class="w-full border-slate-200 my-2">

                <!-- Simulate Scan/Merge -->
                <div class="w-full">
                    <p class="text-sm font-bold text-slate-700 mb-2 flex items-center gap-1"><i data-lucide="download" class="w-4 h-4"></i> スキャン・合体テスト</p>
                    <textarea id="mock-scan-input" class="w-full p-3 border-2 border-slate-300 rounded-xl text-sm font-mono mb-2" rows="3" placeholder="他端末のペイロード文字列をここに貼り付けて合体"></textarea>
                    <button id="btn-merge" class="w-full py-3 bg-emerald-500 text-white font-bold rounded-xl active:bg-emerald-600 shadow-md">
                        データを合体する (OR演算マージ)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide Icons
        lucide.createIcons();

        // --- Core Application State ---
        const GRID_SIZE = 40; // 40x40 logical mesh
        let gridData = new Uint8Array(GRID_SIZE * GRID_SIZE);
        
        // 0: 未処理, 1: 伐採(黄), 2: 集材(橙), 3: 造材(青), 4: 搬出(緑)
        let currentBrush = 1; 
        
        let counters = { felling: 0, yarding: 0, bucking: 0, forwarding: 0 };
        
        // --- Colors ---
        const STATE_COLORS = {
            1: 'rgba(250, 204, 21, 0.7)', // Tailwind yellow-400
            2: 'rgba(249, 115, 22, 0.7)', // Tailwind orange-500
            3: 'rgba(56, 189, 248, 0.7)', // Tailwind sky-400
            4: 'rgba(74, 222, 128, 0.8)'  // Tailwind green-400
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        function resizeCanvas() {
            // Keep it square based on available space
            const size = Math.min(container.clientWidth, container.clientHeight) - 16;
            canvas.width = size;
            canvas.height = size;
            renderCanvas();
        }
        window.addEventListener('resize', resizeCanvas);

        // --- Drawing Logic ---
        function renderCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cellW = canvas.width / GRID_SIZE;
            const cellH = canvas.height / GRID_SIZE;

            // Draw painted cells
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    let val = gridData[y * GRID_SIZE + x];
                    if (val > 0) {
                        ctx.fillStyle = STATE_COLORS[val];
                        // Add slight overlap (+0.5) to prevent visual gaps between cells
                        ctx.fillRect(x * cellW, y * cellH, cellW + 0.5, cellH + 0.5); 
                    }
                }
            }

            // Draw Grid Lines (simulating 5m mesh)
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)'; // slate-400 transparent
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.moveTo(i * cellW, 0);
                ctx.lineTo(i * cellW, canvas.height);
                ctx.moveTo(0, i * cellH);
                ctx.lineTo(canvas.width, i * cellH);
            }
            ctx.stroke();
        }

        // --- Interaction Logic (Touch & Mouse) ---
        let isDrawing = false;
        let lastX = -1;
        let lastY = -1;

        function getGridCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(((clientX - rect.left) / rect.width) * GRID_SIZE);
            const y = Math.floor(((clientY - rect.top) / rect.height) * GRID_SIZE);
            return { 
                x: Math.max(0, Math.min(GRID_SIZE - 1, x)), 
                y: Math.max(0, Math.min(GRID_SIZE - 1, y)) 
            };
        }

        function applyBrush(gx, gy) {
            const idx = gy * GRID_SIZE + gx;
            if (currentBrush === 0) {
                gridData[idx] = 0; // 消しゴムは強制クリア
            } else {
                // 要件: 常に「より進んでいる状態」を優先する論理和 (0 < 1 < 2 < 3 < 4)
                gridData[idx] = Math.max(gridData[idx], currentBrush);
            }
        }

        // Bresenham's line algorithm for smooth continuous painting on swipe
        function drawLine(x0, y0, x1, y1) {
            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = (x0 < x1) ? 1 : -1;
            let sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                applyBrush(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                let e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        function handleStart(e) {
            isDrawing = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const coords = getGridCoords(clientX, clientY);
            lastX = coords.x;
            lastY = coords.y;
            applyBrush(coords.x, coords.y);
            renderCanvas();
        }

        function handleMove(e) {
            if (!isDrawing) return;
            e.preventDefault(); // Prevent scrolling while painting
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const coords = getGridCoords(clientX, clientY);
            drawLine(lastX, lastY, coords.x, coords.y);
            lastX = coords.x;
            lastY = coords.y;
            renderCanvas();
        }

        function handleEnd() {
            isDrawing = false;
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);

        // --- Data Compression & Sync Logic (Requirements) ---

        /**
         * ペイントデータをQR用に圧縮 (RLE + Base64)
         */
        function compressMapData() {
            let rle = "";
            let count = 1;
            let prev = gridData[0];
            // 状態を文字にマッピング (A:未, B:伐, C:集, D:造, E:搬)
            const stateMap = {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'};

            for (let i = 1; i < gridData.length; i++) {
                if (gridData[i] === prev) {
                    count++;
                } else {
                    rle += count + stateMap[prev];
                    prev = gridData[i];
                    count = 1;
                }
            }
            rle += count + stateMap[prev]; // 最後の塊
            
            // Base64エンコード
            return btoa(rle);
        }

        /**
         * QRから読み取った文字列を配列に復元
         */
        function decompressMapData(base64Str) {
            const rle = atob(base64Str);
            const result = new Uint8Array(GRID_SIZE * GRID_SIZE);
            let idx = 0;
            
            // 例: "1500A100B" を解析 (A~Eまで対応)
            const regex = /(\d+)([ABCDE])/g;
            let match;
            const revMap = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4};
            
            while ((match = regex.exec(rle)) !== null) {
                let count = parseInt(match[1], 10);
                let val = revMap[match[2]];
                for (let i = 0; i < count; i++) {
                    if (idx < result.length) result[idx++] = val;
                }
            }
            return result;
        }

        // --- UI Event Listeners ---

        function updateBrushUI() {
            const btns = [
                { id: 'btn-brush-1', val: 1 },
                { id: 'btn-brush-2', val: 2 },
                { id: 'btn-brush-3', val: 3 },
                { id: 'btn-brush-4', val: 4 },
                { id: 'btn-brush-0', val: 0 }
            ];
            
            btns.forEach(b => {
                const el = document.getElementById(b.id);
                el.classList.remove('border-slate-800', 'scale-105', 'shadow-xl');
                if (currentBrush === b.val) {
                    el.classList.add('border-slate-800', 'scale-105', 'shadow-xl');
                    // スクロールエリア内で選択中のボタンが見えるようにする
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            });
        }

        document.getElementById('btn-brush-1').addEventListener('click', () => { currentBrush = 1; updateBrushUI(); });
        document.getElementById('btn-brush-2').addEventListener('click', () => { currentBrush = 2; updateBrushUI(); });
        document.getElementById('btn-brush-3').addEventListener('click', () => { currentBrush = 3; updateBrushUI(); });
        document.getElementById('btn-brush-4').addEventListener('click', () => { currentBrush = 4; updateBrushUI(); });
        document.getElementById('btn-brush-0').addEventListener('click', () => { currentBrush = 0; updateBrushUI(); });

        function updateCountersUI() {
            document.getElementById('ui-count-felling').textContent = counters.felling;
            document.getElementById('ui-count-yarding').textContent = counters.yarding;
            document.getElementById('ui-count-bucking').textContent = counters.bucking;
            document.getElementById('ui-count-forwarding').textContent = counters.forwarding;
        }

        function animateBtn(id, colorClasses) {
            const btn = document.getElementById(id);
            btn.classList.add(...colorClasses, 'text-slate-900');
            setTimeout(() => btn.classList.remove(...colorClasses, 'text-slate-900'), 200);
        }

        document.getElementById('btn-count-felling').addEventListener('click', () => {
            counters.felling += 10; updateCountersUI(); animateBtn('btn-count-felling', ['bg-yellow-500']);
        });
        document.getElementById('btn-count-yarding').addEventListener('click', () => {
            counters.yarding += 10; updateCountersUI(); animateBtn('btn-count-yarding', ['bg-orange-500']);
        });
        document.getElementById('btn-count-bucking').addEventListener('click', () => {
            counters.bucking += 10; updateCountersUI(); animateBtn('btn-count-bucking', ['bg-sky-500']);
        });
        document.getElementById('btn-count-forwarding').addEventListener('click', () => {
            counters.forwarding += 1; updateCountersUI(); animateBtn('btn-count-forwarding', ['bg-green-500']);
        });

        // --- Sync Modal & QR Generation ---
        
        document.getElementById('btn-show-sync').addEventListener('click', () => {
            // ペイロード構築
            const payload = {
                p: compressMapData(),
                c: [counters.felling, counters.yarding, counters.bucking, counters.forwarding]
            };
            const payloadStr = JSON.stringify(payload);
            
            // UI更新
            document.getElementById('sync-payload-text').textContent = payloadStr;
            document.getElementById('mock-scan-input').value = payloadStr; // テスト用に自分自身のデータを初期セット
            
            // QR生成
            const qrContainer = document.getElementById('qrcode-container');
            qrContainer.innerHTML = '';
            new QRCode(qrContainer, {
                text: payloadStr,
                width: 200,
                height: 200,
                colorDark : "#0f172a", // slate-900
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.L // 容量重視
            });

            document.getElementById('sync-modal').classList.remove('hidden');
        });

        document.getElementById('btn-close-modal').addEventListener('click', () => {
            document.getElementById('sync-modal').classList.add('hidden');
        });

        // --- Data Merge Logic (Sync Hub) ---
        
        document.getElementById('btn-merge').addEventListener('click', () => {
            const inputStr = document.getElementById('mock-scan-input').value;
            try {
                const incomingData = JSON.parse(inputStr);
                const incomingGrid = decompressMapData(incomingData.p);
                
                // 1. ペイントデータのマージ (要件: より進んでいる状態を優先する論理和)
                let paintChanged = false;
                for (let i = 0; i < gridData.length; i++) {
                    const maxVal = Math.max(gridData[i], incomingGrid[i]);
                    if (gridData[i] !== maxVal) paintChanged = true;
                    gridData[i] = maxVal;
                }
                
                // 2. カウンターデータのマージ (要件: 別ユーザーは合算)
                counters.felling += incomingData.c[0] || 0;
                counters.yarding += incomingData.c[1] || 0;
                counters.bucking += incomingData.c[2] || 0;
                counters.forwarding += incomingData.c[3] || 0;
                
                updateCountersUI();
                renderCanvas();
                
                document.getElementById('sync-modal').classList.add('hidden');
                
                // 完了通知
                const btn = document.getElementById('btn-show-sync');
                const origText = btn.innerHTML;
                btn.innerHTML = `<i data-lucide="check-circle" class="w-8 h-8"></i> 合体完了！`;
                btn.classList.replace('bg-blue-600', 'bg-emerald-500');
                lucide.createIcons();
                
                setTimeout(() => {
                    btn.innerHTML = origText;
                    btn.classList.replace('bg-emerald-500', 'bg-blue-600');
                }, 2000);

            } catch (e) {
                alert("QRデータの形式が正しくありません。");
                console.error(e);
            }
        });

        // Initialize App
        resizeCanvas();
        updateBrushUI();

    </script>
</body>
</html>
